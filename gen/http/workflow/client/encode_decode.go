// Code generated by goa v3.3.1, DO NOT EDIT.
//
// workflow HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/fuseml/fuseml-core/design

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"

	workflow "github.com/fuseml/fuseml-core/gen/workflow"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildListRequest instantiates a HTTP request object with method and path set
// to call the "workflow" service "list" endpoint
func (c *Client) BuildListRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListWorkflowPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("workflow", "list", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListRequest returns an encoder for requests sent to the workflow list
// server.
func EncodeListRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*workflow.ListPayload)
		if !ok {
			return goahttp.ErrInvalidType("workflow", "list", "*workflow.ListPayload", v)
		}
		values := req.URL.Query()
		if p.Name != nil {
			values.Add("name", *p.Name)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListResponse returns a decoder for responses returned by the workflow
// list endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeListResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- error: internal error
func DecodeListResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("workflow", "list", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateWorkflowResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("workflow", "list", err)
			}
			res := NewListWorkflowOK(body)
			return res, nil
		case http.StatusNotFound:
			var (
				body ListNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("workflow", "list", err)
			}
			err = ValidateListNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("workflow", "list", err)
			}
			return nil, NewListNotFound(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("workflow", "list", resp.StatusCode, string(body))
		}
	}
}

// BuildRegisterRequest instantiates a HTTP request object with method and path
// set to call the "workflow" service "register" endpoint
func (c *Client) BuildRegisterRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RegisterWorkflowPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("workflow", "register", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRegisterRequest returns an encoder for requests sent to the workflow
// register server.
func EncodeRegisterRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*workflow.Workflow)
		if !ok {
			return goahttp.ErrInvalidType("workflow", "register", "*workflow.Workflow", v)
		}
		body := NewRegisterRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("workflow", "register", err)
		}
		return nil
	}
}

// DecodeRegisterResponse returns a decoder for responses returned by the
// workflow register endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeRegisterResponse may return the following errors:
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeRegisterResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body RegisterResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("workflow", "register", err)
			}
			err = ValidateRegisterResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("workflow", "register", err)
			}
			res := NewRegisterWorkflowCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body RegisterBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("workflow", "register", err)
			}
			err = ValidateRegisterBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("workflow", "register", err)
			}
			return nil, NewRegisterBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("workflow", "register", resp.StatusCode, string(body))
		}
	}
}

// BuildGetRequest instantiates a HTTP request object with method and path set
// to call the "workflow" service "get" endpoint
func (c *Client) BuildGetRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		workflowNameOrID string
	)
	{
		p, ok := v.(*workflow.GetPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("workflow", "get", "*workflow.GetPayload", v)
		}
		workflowNameOrID = p.WorkflowNameOrID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetWorkflowPath(workflowNameOrID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("workflow", "get", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetResponse returns a decoder for responses returned by the workflow
// get endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeGetResponse may return the following errors:
//	- "BadRequest" (type *goa.ServiceError): http.StatusBadRequest
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- error: internal error
func DecodeGetResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("workflow", "get", err)
			}
			err = ValidateGetResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("workflow", "get", err)
			}
			res := NewGetWorkflowOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("workflow", "get", err)
			}
			err = ValidateGetBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("workflow", "get", err)
			}
			return nil, NewGetBadRequest(&body)
		case http.StatusNotFound:
			var (
				body GetNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("workflow", "get", err)
			}
			err = ValidateGetNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("workflow", "get", err)
			}
			return nil, NewGetNotFound(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("workflow", "get", resp.StatusCode, string(body))
		}
	}
}

// unmarshalWorkflowResponseToWorkflowWorkflow builds a value of type
// *workflow.Workflow from a value of type *WorkflowResponse.
func unmarshalWorkflowResponseToWorkflowWorkflow(v *WorkflowResponse) *workflow.Workflow {
	res := &workflow.Workflow{
		ID:          v.ID,
		Created:     v.Created,
		Name:        *v.Name,
		Description: v.Description,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*workflow.WorkflowInput, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = unmarshalWorkflowInputResponseToWorkflowWorkflowInput(val)
		}
	}
	if v.Outputs != nil {
		res.Outputs = make([]*workflow.WorkflowOutput, len(v.Outputs))
		for i, val := range v.Outputs {
			res.Outputs[i] = unmarshalWorkflowOutputResponseToWorkflowWorkflowOutput(val)
		}
	}
	res.Steps = make([]*workflow.WorkflowStep, len(v.Steps))
	for i, val := range v.Steps {
		res.Steps[i] = unmarshalWorkflowStepResponseToWorkflowWorkflowStep(val)
	}

	return res
}

// unmarshalWorkflowInputResponseToWorkflowWorkflowInput builds a value of type
// *workflow.WorkflowInput from a value of type *WorkflowInputResponse.
func unmarshalWorkflowInputResponseToWorkflowWorkflowInput(v *WorkflowInputResponse) *workflow.WorkflowInput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowInput{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
		Default:     v.Default,
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// unmarshalWorkflowOutputResponseToWorkflowWorkflowOutput builds a value of
// type *workflow.WorkflowOutput from a value of type *WorkflowOutputResponse.
func unmarshalWorkflowOutputResponseToWorkflowWorkflowOutput(v *WorkflowOutputResponse) *workflow.WorkflowOutput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowOutput{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
	}

	return res
}

// unmarshalWorkflowStepResponseToWorkflowWorkflowStep builds a value of type
// *workflow.WorkflowStep from a value of type *WorkflowStepResponse.
func unmarshalWorkflowStepResponseToWorkflowWorkflowStep(v *WorkflowStepResponse) *workflow.WorkflowStep {
	res := &workflow.WorkflowStep{
		Name:  v.Name,
		Image: v.Image,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*workflow.WorkflowStepInput, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = unmarshalWorkflowStepInputResponseToWorkflowWorkflowStepInput(val)
		}
	}
	if v.Outputs != nil {
		res.Outputs = make([]*workflow.WorkflowStepOutput, len(v.Outputs))
		for i, val := range v.Outputs {
			res.Outputs[i] = unmarshalWorkflowStepOutputResponseToWorkflowWorkflowStepOutput(val)
		}
	}
	if v.Env != nil {
		res.Env = make([]*workflow.StepEnv, len(v.Env))
		for i, val := range v.Env {
			res.Env[i] = unmarshalStepEnvResponseToWorkflowStepEnv(val)
		}
	}

	return res
}

// unmarshalWorkflowStepInputResponseToWorkflowWorkflowStepInput builds a value
// of type *workflow.WorkflowStepInput from a value of type
// *WorkflowStepInputResponse.
func unmarshalWorkflowStepInputResponseToWorkflowWorkflowStepInput(v *WorkflowStepInputResponse) *workflow.WorkflowStepInput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowStepInput{
		Name:  v.Name,
		Value: v.Value,
	}
	if v.Codeset != nil {
		res.Codeset = unmarshalStepInputCodesetResponseToWorkflowStepInputCodeset(v.Codeset)
	}

	return res
}

// unmarshalStepInputCodesetResponseToWorkflowStepInputCodeset builds a value
// of type *workflow.StepInputCodeset from a value of type
// *StepInputCodesetResponse.
func unmarshalStepInputCodesetResponseToWorkflowStepInputCodeset(v *StepInputCodesetResponse) *workflow.StepInputCodeset {
	if v == nil {
		return nil
	}
	res := &workflow.StepInputCodeset{
		Name: v.Name,
		Path: v.Path,
	}

	return res
}

// unmarshalWorkflowStepOutputResponseToWorkflowWorkflowStepOutput builds a
// value of type *workflow.WorkflowStepOutput from a value of type
// *WorkflowStepOutputResponse.
func unmarshalWorkflowStepOutputResponseToWorkflowWorkflowStepOutput(v *WorkflowStepOutputResponse) *workflow.WorkflowStepOutput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowStepOutput{
		Name: v.Name,
	}
	if v.Image != nil {
		res.Image = unmarshalStepOutputImageResponseToWorkflowStepOutputImage(v.Image)
	}

	return res
}

// unmarshalStepOutputImageResponseToWorkflowStepOutputImage builds a value of
// type *workflow.StepOutputImage from a value of type *StepOutputImageResponse.
func unmarshalStepOutputImageResponseToWorkflowStepOutputImage(v *StepOutputImageResponse) *workflow.StepOutputImage {
	if v == nil {
		return nil
	}
	res := &workflow.StepOutputImage{
		Dockerfile: v.Dockerfile,
		Name:       v.Name,
	}

	return res
}

// unmarshalStepEnvResponseToWorkflowStepEnv builds a value of type
// *workflow.StepEnv from a value of type *StepEnvResponse.
func unmarshalStepEnvResponseToWorkflowStepEnv(v *StepEnvResponse) *workflow.StepEnv {
	if v == nil {
		return nil
	}
	res := &workflow.StepEnv{
		Name:  v.Name,
		Value: v.Value,
	}

	return res
}

// marshalWorkflowWorkflowInputToWorkflowInputRequestBody builds a value of
// type *WorkflowInputRequestBody from a value of type *workflow.WorkflowInput.
func marshalWorkflowWorkflowInputToWorkflowInputRequestBody(v *workflow.WorkflowInput) *WorkflowInputRequestBody {
	if v == nil {
		return nil
	}
	res := &WorkflowInputRequestBody{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
		Default:     v.Default,
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// marshalWorkflowWorkflowOutputToWorkflowOutputRequestBody builds a value of
// type *WorkflowOutputRequestBody from a value of type
// *workflow.WorkflowOutput.
func marshalWorkflowWorkflowOutputToWorkflowOutputRequestBody(v *workflow.WorkflowOutput) *WorkflowOutputRequestBody {
	if v == nil {
		return nil
	}
	res := &WorkflowOutputRequestBody{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
	}

	return res
}

// marshalWorkflowWorkflowStepToWorkflowStepRequestBody builds a value of type
// *WorkflowStepRequestBody from a value of type *workflow.WorkflowStep.
func marshalWorkflowWorkflowStepToWorkflowStepRequestBody(v *workflow.WorkflowStep) *WorkflowStepRequestBody {
	res := &WorkflowStepRequestBody{
		Name:  v.Name,
		Image: v.Image,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*WorkflowStepInputRequestBody, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = marshalWorkflowWorkflowStepInputToWorkflowStepInputRequestBody(val)
		}
	}
	if v.Outputs != nil {
		res.Outputs = make([]*WorkflowStepOutputRequestBody, len(v.Outputs))
		for i, val := range v.Outputs {
			res.Outputs[i] = marshalWorkflowWorkflowStepOutputToWorkflowStepOutputRequestBody(val)
		}
	}
	if v.Env != nil {
		res.Env = make([]*StepEnvRequestBody, len(v.Env))
		for i, val := range v.Env {
			res.Env[i] = marshalWorkflowStepEnvToStepEnvRequestBody(val)
		}
	}

	return res
}

// marshalWorkflowWorkflowStepInputToWorkflowStepInputRequestBody builds a
// value of type *WorkflowStepInputRequestBody from a value of type
// *workflow.WorkflowStepInput.
func marshalWorkflowWorkflowStepInputToWorkflowStepInputRequestBody(v *workflow.WorkflowStepInput) *WorkflowStepInputRequestBody {
	if v == nil {
		return nil
	}
	res := &WorkflowStepInputRequestBody{
		Name:  v.Name,
		Value: v.Value,
	}
	if v.Codeset != nil {
		res.Codeset = marshalWorkflowStepInputCodesetToStepInputCodesetRequestBody(v.Codeset)
	}

	return res
}

// marshalWorkflowStepInputCodesetToStepInputCodesetRequestBody builds a value
// of type *StepInputCodesetRequestBody from a value of type
// *workflow.StepInputCodeset.
func marshalWorkflowStepInputCodesetToStepInputCodesetRequestBody(v *workflow.StepInputCodeset) *StepInputCodesetRequestBody {
	if v == nil {
		return nil
	}
	res := &StepInputCodesetRequestBody{
		Name: v.Name,
		Path: v.Path,
	}

	return res
}

// marshalWorkflowWorkflowStepOutputToWorkflowStepOutputRequestBody builds a
// value of type *WorkflowStepOutputRequestBody from a value of type
// *workflow.WorkflowStepOutput.
func marshalWorkflowWorkflowStepOutputToWorkflowStepOutputRequestBody(v *workflow.WorkflowStepOutput) *WorkflowStepOutputRequestBody {
	if v == nil {
		return nil
	}
	res := &WorkflowStepOutputRequestBody{
		Name: v.Name,
	}
	if v.Image != nil {
		res.Image = marshalWorkflowStepOutputImageToStepOutputImageRequestBody(v.Image)
	}

	return res
}

// marshalWorkflowStepOutputImageToStepOutputImageRequestBody builds a value of
// type *StepOutputImageRequestBody from a value of type
// *workflow.StepOutputImage.
func marshalWorkflowStepOutputImageToStepOutputImageRequestBody(v *workflow.StepOutputImage) *StepOutputImageRequestBody {
	if v == nil {
		return nil
	}
	res := &StepOutputImageRequestBody{
		Dockerfile: v.Dockerfile,
		Name:       v.Name,
	}

	return res
}

// marshalWorkflowStepEnvToStepEnvRequestBody builds a value of type
// *StepEnvRequestBody from a value of type *workflow.StepEnv.
func marshalWorkflowStepEnvToStepEnvRequestBody(v *workflow.StepEnv) *StepEnvRequestBody {
	if v == nil {
		return nil
	}
	res := &StepEnvRequestBody{
		Name:  v.Name,
		Value: v.Value,
	}

	return res
}

// marshalWorkflowInputRequestBodyToWorkflowWorkflowInput builds a value of
// type *workflow.WorkflowInput from a value of type *WorkflowInputRequestBody.
func marshalWorkflowInputRequestBodyToWorkflowWorkflowInput(v *WorkflowInputRequestBody) *workflow.WorkflowInput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowInput{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
		Default:     v.Default,
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// marshalWorkflowOutputRequestBodyToWorkflowWorkflowOutput builds a value of
// type *workflow.WorkflowOutput from a value of type
// *WorkflowOutputRequestBody.
func marshalWorkflowOutputRequestBodyToWorkflowWorkflowOutput(v *WorkflowOutputRequestBody) *workflow.WorkflowOutput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowOutput{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
	}

	return res
}

// marshalWorkflowStepRequestBodyToWorkflowWorkflowStep builds a value of type
// *workflow.WorkflowStep from a value of type *WorkflowStepRequestBody.
func marshalWorkflowStepRequestBodyToWorkflowWorkflowStep(v *WorkflowStepRequestBody) *workflow.WorkflowStep {
	res := &workflow.WorkflowStep{
		Name:  v.Name,
		Image: v.Image,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*workflow.WorkflowStepInput, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = marshalWorkflowStepInputRequestBodyToWorkflowWorkflowStepInput(val)
		}
	}
	if v.Outputs != nil {
		res.Outputs = make([]*workflow.WorkflowStepOutput, len(v.Outputs))
		for i, val := range v.Outputs {
			res.Outputs[i] = marshalWorkflowStepOutputRequestBodyToWorkflowWorkflowStepOutput(val)
		}
	}
	if v.Env != nil {
		res.Env = make([]*workflow.StepEnv, len(v.Env))
		for i, val := range v.Env {
			res.Env[i] = marshalStepEnvRequestBodyToWorkflowStepEnv(val)
		}
	}

	return res
}

// marshalWorkflowStepInputRequestBodyToWorkflowWorkflowStepInput builds a
// value of type *workflow.WorkflowStepInput from a value of type
// *WorkflowStepInputRequestBody.
func marshalWorkflowStepInputRequestBodyToWorkflowWorkflowStepInput(v *WorkflowStepInputRequestBody) *workflow.WorkflowStepInput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowStepInput{
		Name:  v.Name,
		Value: v.Value,
	}
	if v.Codeset != nil {
		res.Codeset = marshalStepInputCodesetRequestBodyToWorkflowStepInputCodeset(v.Codeset)
	}

	return res
}

// marshalStepInputCodesetRequestBodyToWorkflowStepInputCodeset builds a value
// of type *workflow.StepInputCodeset from a value of type
// *StepInputCodesetRequestBody.
func marshalStepInputCodesetRequestBodyToWorkflowStepInputCodeset(v *StepInputCodesetRequestBody) *workflow.StepInputCodeset {
	if v == nil {
		return nil
	}
	res := &workflow.StepInputCodeset{
		Name: v.Name,
		Path: v.Path,
	}

	return res
}

// marshalWorkflowStepOutputRequestBodyToWorkflowWorkflowStepOutput builds a
// value of type *workflow.WorkflowStepOutput from a value of type
// *WorkflowStepOutputRequestBody.
func marshalWorkflowStepOutputRequestBodyToWorkflowWorkflowStepOutput(v *WorkflowStepOutputRequestBody) *workflow.WorkflowStepOutput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowStepOutput{
		Name: v.Name,
	}
	if v.Image != nil {
		res.Image = marshalStepOutputImageRequestBodyToWorkflowStepOutputImage(v.Image)
	}

	return res
}

// marshalStepOutputImageRequestBodyToWorkflowStepOutputImage builds a value of
// type *workflow.StepOutputImage from a value of type
// *StepOutputImageRequestBody.
func marshalStepOutputImageRequestBodyToWorkflowStepOutputImage(v *StepOutputImageRequestBody) *workflow.StepOutputImage {
	if v == nil {
		return nil
	}
	res := &workflow.StepOutputImage{
		Dockerfile: v.Dockerfile,
		Name:       v.Name,
	}

	return res
}

// marshalStepEnvRequestBodyToWorkflowStepEnv builds a value of type
// *workflow.StepEnv from a value of type *StepEnvRequestBody.
func marshalStepEnvRequestBodyToWorkflowStepEnv(v *StepEnvRequestBody) *workflow.StepEnv {
	if v == nil {
		return nil
	}
	res := &workflow.StepEnv{
		Name:  v.Name,
		Value: v.Value,
	}

	return res
}

// unmarshalWorkflowInputResponseBodyToWorkflowWorkflowInput builds a value of
// type *workflow.WorkflowInput from a value of type *WorkflowInputResponseBody.
func unmarshalWorkflowInputResponseBodyToWorkflowWorkflowInput(v *WorkflowInputResponseBody) *workflow.WorkflowInput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowInput{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
		Default:     v.Default,
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// unmarshalWorkflowOutputResponseBodyToWorkflowWorkflowOutput builds a value
// of type *workflow.WorkflowOutput from a value of type
// *WorkflowOutputResponseBody.
func unmarshalWorkflowOutputResponseBodyToWorkflowWorkflowOutput(v *WorkflowOutputResponseBody) *workflow.WorkflowOutput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowOutput{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
	}

	return res
}

// unmarshalWorkflowStepResponseBodyToWorkflowWorkflowStep builds a value of
// type *workflow.WorkflowStep from a value of type *WorkflowStepResponseBody.
func unmarshalWorkflowStepResponseBodyToWorkflowWorkflowStep(v *WorkflowStepResponseBody) *workflow.WorkflowStep {
	res := &workflow.WorkflowStep{
		Name:  v.Name,
		Image: v.Image,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*workflow.WorkflowStepInput, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = unmarshalWorkflowStepInputResponseBodyToWorkflowWorkflowStepInput(val)
		}
	}
	if v.Outputs != nil {
		res.Outputs = make([]*workflow.WorkflowStepOutput, len(v.Outputs))
		for i, val := range v.Outputs {
			res.Outputs[i] = unmarshalWorkflowStepOutputResponseBodyToWorkflowWorkflowStepOutput(val)
		}
	}
	if v.Env != nil {
		res.Env = make([]*workflow.StepEnv, len(v.Env))
		for i, val := range v.Env {
			res.Env[i] = unmarshalStepEnvResponseBodyToWorkflowStepEnv(val)
		}
	}

	return res
}

// unmarshalWorkflowStepInputResponseBodyToWorkflowWorkflowStepInput builds a
// value of type *workflow.WorkflowStepInput from a value of type
// *WorkflowStepInputResponseBody.
func unmarshalWorkflowStepInputResponseBodyToWorkflowWorkflowStepInput(v *WorkflowStepInputResponseBody) *workflow.WorkflowStepInput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowStepInput{
		Name:  v.Name,
		Value: v.Value,
	}
	if v.Codeset != nil {
		res.Codeset = unmarshalStepInputCodesetResponseBodyToWorkflowStepInputCodeset(v.Codeset)
	}

	return res
}

// unmarshalStepInputCodesetResponseBodyToWorkflowStepInputCodeset builds a
// value of type *workflow.StepInputCodeset from a value of type
// *StepInputCodesetResponseBody.
func unmarshalStepInputCodesetResponseBodyToWorkflowStepInputCodeset(v *StepInputCodesetResponseBody) *workflow.StepInputCodeset {
	if v == nil {
		return nil
	}
	res := &workflow.StepInputCodeset{
		Name: v.Name,
		Path: v.Path,
	}

	return res
}

// unmarshalWorkflowStepOutputResponseBodyToWorkflowWorkflowStepOutput builds a
// value of type *workflow.WorkflowStepOutput from a value of type
// *WorkflowStepOutputResponseBody.
func unmarshalWorkflowStepOutputResponseBodyToWorkflowWorkflowStepOutput(v *WorkflowStepOutputResponseBody) *workflow.WorkflowStepOutput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowStepOutput{
		Name: v.Name,
	}
	if v.Image != nil {
		res.Image = unmarshalStepOutputImageResponseBodyToWorkflowStepOutputImage(v.Image)
	}

	return res
}

// unmarshalStepOutputImageResponseBodyToWorkflowStepOutputImage builds a value
// of type *workflow.StepOutputImage from a value of type
// *StepOutputImageResponseBody.
func unmarshalStepOutputImageResponseBodyToWorkflowStepOutputImage(v *StepOutputImageResponseBody) *workflow.StepOutputImage {
	if v == nil {
		return nil
	}
	res := &workflow.StepOutputImage{
		Dockerfile: v.Dockerfile,
		Name:       v.Name,
	}

	return res
}

// unmarshalStepEnvResponseBodyToWorkflowStepEnv builds a value of type
// *workflow.StepEnv from a value of type *StepEnvResponseBody.
func unmarshalStepEnvResponseBodyToWorkflowStepEnv(v *StepEnvResponseBody) *workflow.StepEnv {
	if v == nil {
		return nil
	}
	res := &workflow.StepEnv{
		Name:  v.Name,
		Value: v.Value,
	}

	return res
}
