// Code generated by goa v3.3.1, DO NOT EDIT.
//
// workflow HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/fuseml/fuseml-core/design

package server

import (
	"context"
	"io"
	"net/http"

	workflow "github.com/fuseml/fuseml-core/gen/workflow"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeListResponse returns an encoder for responses returned by the workflow
// list endpoint.
func EncodeListResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.([]*workflow.Workflow)
		enc := encoder(ctx, w)
		body := NewListResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListRequest returns a decoder for requests sent to the workflow list
// endpoint.
func DecodeListRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			name *string
		)
		nameRaw := r.URL.Query().Get("name")
		if nameRaw != "" {
			name = &nameRaw
		}
		payload := NewListPayload(name)

		return payload, nil
	}
}

// EncodeListError returns an encoder for errors returned by the list workflow
// endpoint.
func EncodeListError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "NotFound":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "NotFound")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRegisterResponse returns an encoder for responses returned by the
// workflow register endpoint.
func EncodeRegisterResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*workflow.Workflow)
		enc := encoder(ctx, w)
		body := NewRegisterResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeRegisterRequest returns a decoder for requests sent to the workflow
// register endpoint.
func DecodeRegisterRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body RegisterRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateRegisterRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewRegisterWorkflow(&body)

		return payload, nil
	}
}

// EncodeRegisterError returns an encoder for errors returned by the register
// workflow endpoint.
func EncodeRegisterError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "BadRequest":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewRegisterBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "BadRequest")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetResponse returns an encoder for responses returned by the workflow
// get endpoint.
func EncodeGetResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*workflow.Workflow)
		enc := encoder(ctx, w)
		body := NewGetResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetRequest returns a decoder for requests sent to the workflow get
// endpoint.
func DecodeGetRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			workflowNameOrID string

			params = mux.Vars(r)
		)
		workflowNameOrID = params["workflowNameOrId"]
		payload := NewGetPayload(workflowNameOrID)

		return payload, nil
	}
}

// EncodeGetError returns an encoder for errors returned by the get workflow
// endpoint.
func EncodeGetError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "BadRequest":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "BadRequest")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "NotFound":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "NotFound")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalWorkflowWorkflowToWorkflowResponse builds a value of type
// *WorkflowResponse from a value of type *workflow.Workflow.
func marshalWorkflowWorkflowToWorkflowResponse(v *workflow.Workflow) *WorkflowResponse {
	res := &WorkflowResponse{
		ID:          v.ID,
		Created:     v.Created,
		Name:        v.Name,
		Description: v.Description,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*WorkflowInputResponse, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = marshalWorkflowWorkflowInputToWorkflowInputResponse(val)
		}
	}
	if v.Outputs != nil {
		res.Outputs = make([]*WorkflowOutputResponse, len(v.Outputs))
		for i, val := range v.Outputs {
			res.Outputs[i] = marshalWorkflowWorkflowOutputToWorkflowOutputResponse(val)
		}
	}
	if v.Steps != nil {
		res.Steps = make([]*WorkflowStepResponse, len(v.Steps))
		for i, val := range v.Steps {
			res.Steps[i] = marshalWorkflowWorkflowStepToWorkflowStepResponse(val)
		}
	}

	return res
}

// marshalWorkflowWorkflowInputToWorkflowInputResponse builds a value of type
// *WorkflowInputResponse from a value of type *workflow.WorkflowInput.
func marshalWorkflowWorkflowInputToWorkflowInputResponse(v *workflow.WorkflowInput) *WorkflowInputResponse {
	if v == nil {
		return nil
	}
	res := &WorkflowInputResponse{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
		Default:     v.Default,
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// marshalWorkflowWorkflowOutputToWorkflowOutputResponse builds a value of type
// *WorkflowOutputResponse from a value of type *workflow.WorkflowOutput.
func marshalWorkflowWorkflowOutputToWorkflowOutputResponse(v *workflow.WorkflowOutput) *WorkflowOutputResponse {
	if v == nil {
		return nil
	}
	res := &WorkflowOutputResponse{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
	}

	return res
}

// marshalWorkflowWorkflowStepToWorkflowStepResponse builds a value of type
// *WorkflowStepResponse from a value of type *workflow.WorkflowStep.
func marshalWorkflowWorkflowStepToWorkflowStepResponse(v *workflow.WorkflowStep) *WorkflowStepResponse {
	res := &WorkflowStepResponse{
		Name:  v.Name,
		Image: v.Image,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*WorkflowStepInputResponse, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = marshalWorkflowWorkflowStepInputToWorkflowStepInputResponse(val)
		}
	}
	if v.Outputs != nil {
		res.Outputs = make([]*WorkflowStepOutputResponse, len(v.Outputs))
		for i, val := range v.Outputs {
			res.Outputs[i] = marshalWorkflowWorkflowStepOutputToWorkflowStepOutputResponse(val)
		}
	}
	if v.Env != nil {
		res.Env = make([]*StepEnvResponse, len(v.Env))
		for i, val := range v.Env {
			res.Env[i] = marshalWorkflowStepEnvToStepEnvResponse(val)
		}
	}

	return res
}

// marshalWorkflowWorkflowStepInputToWorkflowStepInputResponse builds a value
// of type *WorkflowStepInputResponse from a value of type
// *workflow.WorkflowStepInput.
func marshalWorkflowWorkflowStepInputToWorkflowStepInputResponse(v *workflow.WorkflowStepInput) *WorkflowStepInputResponse {
	if v == nil {
		return nil
	}
	res := &WorkflowStepInputResponse{
		Name:  v.Name,
		Value: v.Value,
	}
	if v.Codeset != nil {
		res.Codeset = marshalWorkflowStepInputCodesetToStepInputCodesetResponse(v.Codeset)
	}

	return res
}

// marshalWorkflowStepInputCodesetToStepInputCodesetResponse builds a value of
// type *StepInputCodesetResponse from a value of type
// *workflow.StepInputCodeset.
func marshalWorkflowStepInputCodesetToStepInputCodesetResponse(v *workflow.StepInputCodeset) *StepInputCodesetResponse {
	if v == nil {
		return nil
	}
	res := &StepInputCodesetResponse{
		Name: v.Name,
		Path: v.Path,
	}

	return res
}

// marshalWorkflowWorkflowStepOutputToWorkflowStepOutputResponse builds a value
// of type *WorkflowStepOutputResponse from a value of type
// *workflow.WorkflowStepOutput.
func marshalWorkflowWorkflowStepOutputToWorkflowStepOutputResponse(v *workflow.WorkflowStepOutput) *WorkflowStepOutputResponse {
	if v == nil {
		return nil
	}
	res := &WorkflowStepOutputResponse{
		Name: v.Name,
	}
	if v.Image != nil {
		res.Image = marshalWorkflowStepOutputImageToStepOutputImageResponse(v.Image)
	}

	return res
}

// marshalWorkflowStepOutputImageToStepOutputImageResponse builds a value of
// type *StepOutputImageResponse from a value of type *workflow.StepOutputImage.
func marshalWorkflowStepOutputImageToStepOutputImageResponse(v *workflow.StepOutputImage) *StepOutputImageResponse {
	if v == nil {
		return nil
	}
	res := &StepOutputImageResponse{
		Dockerfile: v.Dockerfile,
		Name:       v.Name,
	}

	return res
}

// marshalWorkflowStepEnvToStepEnvResponse builds a value of type
// *StepEnvResponse from a value of type *workflow.StepEnv.
func marshalWorkflowStepEnvToStepEnvResponse(v *workflow.StepEnv) *StepEnvResponse {
	if v == nil {
		return nil
	}
	res := &StepEnvResponse{
		Name:  v.Name,
		Value: v.Value,
	}

	return res
}

// unmarshalWorkflowInputRequestBodyToWorkflowWorkflowInput builds a value of
// type *workflow.WorkflowInput from a value of type *WorkflowInputRequestBody.
func unmarshalWorkflowInputRequestBodyToWorkflowWorkflowInput(v *WorkflowInputRequestBody) *workflow.WorkflowInput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowInput{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
		Default:     v.Default,
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// unmarshalWorkflowOutputRequestBodyToWorkflowWorkflowOutput builds a value of
// type *workflow.WorkflowOutput from a value of type
// *WorkflowOutputRequestBody.
func unmarshalWorkflowOutputRequestBodyToWorkflowWorkflowOutput(v *WorkflowOutputRequestBody) *workflow.WorkflowOutput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowOutput{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
	}

	return res
}

// unmarshalWorkflowStepRequestBodyToWorkflowWorkflowStep builds a value of
// type *workflow.WorkflowStep from a value of type *WorkflowStepRequestBody.
func unmarshalWorkflowStepRequestBodyToWorkflowWorkflowStep(v *WorkflowStepRequestBody) *workflow.WorkflowStep {
	res := &workflow.WorkflowStep{
		Name:  v.Name,
		Image: v.Image,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*workflow.WorkflowStepInput, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = unmarshalWorkflowStepInputRequestBodyToWorkflowWorkflowStepInput(val)
		}
	}
	if v.Outputs != nil {
		res.Outputs = make([]*workflow.WorkflowStepOutput, len(v.Outputs))
		for i, val := range v.Outputs {
			res.Outputs[i] = unmarshalWorkflowStepOutputRequestBodyToWorkflowWorkflowStepOutput(val)
		}
	}
	if v.Env != nil {
		res.Env = make([]*workflow.StepEnv, len(v.Env))
		for i, val := range v.Env {
			res.Env[i] = unmarshalStepEnvRequestBodyToWorkflowStepEnv(val)
		}
	}

	return res
}

// unmarshalWorkflowStepInputRequestBodyToWorkflowWorkflowStepInput builds a
// value of type *workflow.WorkflowStepInput from a value of type
// *WorkflowStepInputRequestBody.
func unmarshalWorkflowStepInputRequestBodyToWorkflowWorkflowStepInput(v *WorkflowStepInputRequestBody) *workflow.WorkflowStepInput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowStepInput{
		Name:  v.Name,
		Value: v.Value,
	}
	if v.Codeset != nil {
		res.Codeset = unmarshalStepInputCodesetRequestBodyToWorkflowStepInputCodeset(v.Codeset)
	}

	return res
}

// unmarshalStepInputCodesetRequestBodyToWorkflowStepInputCodeset builds a
// value of type *workflow.StepInputCodeset from a value of type
// *StepInputCodesetRequestBody.
func unmarshalStepInputCodesetRequestBodyToWorkflowStepInputCodeset(v *StepInputCodesetRequestBody) *workflow.StepInputCodeset {
	if v == nil {
		return nil
	}
	res := &workflow.StepInputCodeset{
		Name: v.Name,
		Path: v.Path,
	}

	return res
}

// unmarshalWorkflowStepOutputRequestBodyToWorkflowWorkflowStepOutput builds a
// value of type *workflow.WorkflowStepOutput from a value of type
// *WorkflowStepOutputRequestBody.
func unmarshalWorkflowStepOutputRequestBodyToWorkflowWorkflowStepOutput(v *WorkflowStepOutputRequestBody) *workflow.WorkflowStepOutput {
	if v == nil {
		return nil
	}
	res := &workflow.WorkflowStepOutput{
		Name: v.Name,
	}
	if v.Image != nil {
		res.Image = unmarshalStepOutputImageRequestBodyToWorkflowStepOutputImage(v.Image)
	}

	return res
}

// unmarshalStepOutputImageRequestBodyToWorkflowStepOutputImage builds a value
// of type *workflow.StepOutputImage from a value of type
// *StepOutputImageRequestBody.
func unmarshalStepOutputImageRequestBodyToWorkflowStepOutputImage(v *StepOutputImageRequestBody) *workflow.StepOutputImage {
	if v == nil {
		return nil
	}
	res := &workflow.StepOutputImage{
		Dockerfile: v.Dockerfile,
		Name:       v.Name,
	}

	return res
}

// unmarshalStepEnvRequestBodyToWorkflowStepEnv builds a value of type
// *workflow.StepEnv from a value of type *StepEnvRequestBody.
func unmarshalStepEnvRequestBodyToWorkflowStepEnv(v *StepEnvRequestBody) *workflow.StepEnv {
	if v == nil {
		return nil
	}
	res := &workflow.StepEnv{
		Name:  v.Name,
		Value: v.Value,
	}

	return res
}

// marshalWorkflowWorkflowInputToWorkflowInputResponseBody builds a value of
// type *WorkflowInputResponseBody from a value of type *workflow.WorkflowInput.
func marshalWorkflowWorkflowInputToWorkflowInputResponseBody(v *workflow.WorkflowInput) *WorkflowInputResponseBody {
	if v == nil {
		return nil
	}
	res := &WorkflowInputResponseBody{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
		Default:     v.Default,
	}
	if v.Labels != nil {
		res.Labels = make([]string, len(v.Labels))
		for i, val := range v.Labels {
			res.Labels[i] = val
		}
	}

	return res
}

// marshalWorkflowWorkflowOutputToWorkflowOutputResponseBody builds a value of
// type *WorkflowOutputResponseBody from a value of type
// *workflow.WorkflowOutput.
func marshalWorkflowWorkflowOutputToWorkflowOutputResponseBody(v *workflow.WorkflowOutput) *WorkflowOutputResponseBody {
	if v == nil {
		return nil
	}
	res := &WorkflowOutputResponseBody{
		Name:        v.Name,
		Description: v.Description,
		Type:        v.Type,
	}

	return res
}

// marshalWorkflowWorkflowStepToWorkflowStepResponseBody builds a value of type
// *WorkflowStepResponseBody from a value of type *workflow.WorkflowStep.
func marshalWorkflowWorkflowStepToWorkflowStepResponseBody(v *workflow.WorkflowStep) *WorkflowStepResponseBody {
	res := &WorkflowStepResponseBody{
		Name:  v.Name,
		Image: v.Image,
	}
	if v.Inputs != nil {
		res.Inputs = make([]*WorkflowStepInputResponseBody, len(v.Inputs))
		for i, val := range v.Inputs {
			res.Inputs[i] = marshalWorkflowWorkflowStepInputToWorkflowStepInputResponseBody(val)
		}
	}
	if v.Outputs != nil {
		res.Outputs = make([]*WorkflowStepOutputResponseBody, len(v.Outputs))
		for i, val := range v.Outputs {
			res.Outputs[i] = marshalWorkflowWorkflowStepOutputToWorkflowStepOutputResponseBody(val)
		}
	}
	if v.Env != nil {
		res.Env = make([]*StepEnvResponseBody, len(v.Env))
		for i, val := range v.Env {
			res.Env[i] = marshalWorkflowStepEnvToStepEnvResponseBody(val)
		}
	}

	return res
}

// marshalWorkflowWorkflowStepInputToWorkflowStepInputResponseBody builds a
// value of type *WorkflowStepInputResponseBody from a value of type
// *workflow.WorkflowStepInput.
func marshalWorkflowWorkflowStepInputToWorkflowStepInputResponseBody(v *workflow.WorkflowStepInput) *WorkflowStepInputResponseBody {
	if v == nil {
		return nil
	}
	res := &WorkflowStepInputResponseBody{
		Name:  v.Name,
		Value: v.Value,
	}
	if v.Codeset != nil {
		res.Codeset = marshalWorkflowStepInputCodesetToStepInputCodesetResponseBody(v.Codeset)
	}

	return res
}

// marshalWorkflowStepInputCodesetToStepInputCodesetResponseBody builds a value
// of type *StepInputCodesetResponseBody from a value of type
// *workflow.StepInputCodeset.
func marshalWorkflowStepInputCodesetToStepInputCodesetResponseBody(v *workflow.StepInputCodeset) *StepInputCodesetResponseBody {
	if v == nil {
		return nil
	}
	res := &StepInputCodesetResponseBody{
		Name: v.Name,
		Path: v.Path,
	}

	return res
}

// marshalWorkflowWorkflowStepOutputToWorkflowStepOutputResponseBody builds a
// value of type *WorkflowStepOutputResponseBody from a value of type
// *workflow.WorkflowStepOutput.
func marshalWorkflowWorkflowStepOutputToWorkflowStepOutputResponseBody(v *workflow.WorkflowStepOutput) *WorkflowStepOutputResponseBody {
	if v == nil {
		return nil
	}
	res := &WorkflowStepOutputResponseBody{
		Name: v.Name,
	}
	if v.Image != nil {
		res.Image = marshalWorkflowStepOutputImageToStepOutputImageResponseBody(v.Image)
	}

	return res
}

// marshalWorkflowStepOutputImageToStepOutputImageResponseBody builds a value
// of type *StepOutputImageResponseBody from a value of type
// *workflow.StepOutputImage.
func marshalWorkflowStepOutputImageToStepOutputImageResponseBody(v *workflow.StepOutputImage) *StepOutputImageResponseBody {
	if v == nil {
		return nil
	}
	res := &StepOutputImageResponseBody{
		Dockerfile: v.Dockerfile,
		Name:       v.Name,
	}

	return res
}

// marshalWorkflowStepEnvToStepEnvResponseBody builds a value of type
// *StepEnvResponseBody from a value of type *workflow.StepEnv.
func marshalWorkflowStepEnvToStepEnvResponseBody(v *workflow.StepEnv) *StepEnvResponseBody {
	if v == nil {
		return nil
	}
	res := &StepEnvResponseBody{
		Name:  v.Name,
		Value: v.Value,
	}

	return res
}
